# 关系数据库

区别于文档数据库使用文档的形式存储数据，关系数据库使用**表格**来存储信息



网状模型、层次模型：访问复杂，没有分离



## 设计理念

原设计中，应用和数据库耦合过高。**一旦需要改动，则需要作出大量修改**

==将APP与数据库接口变得简单==

==用户只需要给出需要什么信息==

将app与数据库分离



声明式编程：只需要描述想要什么，不需要指明过程

==谓词逻辑==

1阶逻辑，2阶逻辑



## 关系模型

域：同一数据类型的集合（某属性的取值），可有限可无限



## SQL



CRUD

DDL：定义数据格式，创建一张张表格

DQL：在表格上进行数据的查找

DML：对数据进行改动或者删除



### 多表查询

### 嵌套查询

All Any

相关子查询：子查询需要父查询中的内容

此时，对父查询中的每一个取值，代入子查询中，将得到的子查询结果通过where进行判断



### 视图

对已有查询的包装

对视图的修改会修改实体表格数据

修改方式需要唯一



使用==groupby==时，只能输出分组标准和聚合属性。

因为分组标准中，其他属性可能有不同的可能，所以不能输出。



索引：在投影式扫描叶子结点即可



关系数据库：规则事先约定，若要修改则需修改规则，开销较大，可扩展性低



# 基本实现

计算层

存储层

首先从存储层获得数据，传递给计算层，通过计算将结果返回给APP



## 存储层

按页存储，每一页存储若干元组

通过一个数据结构（如B树）将所有的页连接起来，这一数据结构称为表头，如Inode



## 计算层

重要部分：**查询处理**

- 翻译（Interpretation）：将SQL查询翻译成关系代数表达式

  但是表达式不唯一，需要找到最优的查询计划

- 查询优化（Query optimization）：需要预测，使用AI技术，通过模型来预测

  关系数据库带有一定的智能性

- 查询执行（Query evaluation）：得到最终结果



## 性能

时间：数据密集型的问题由IO的次数影响

好算法：IO次数少的算法



## 算子的实现方式



### 选择

扫描 Scan

索引访问 Index Access

如果某数据经常被更新，则不适合使用索引

如果某索引覆盖率较大，则使用索引可能比扫描需要更多次IO，此时也不适合使用索引



### 投影

去重

排序：考虑**局部性**

先排一部分，写入硬盘，再排后一部分，写入硬盘，不断重复

对排序结果进行归并



### IO优先算法



#### 嵌套循环

R表，S表

每个R数据与S作对比

对于每一个R都需要读取B（S），所以有R B(S)

读取每一个R有B(R)

所以总共读取B(R)+R B(S)

相对稳定



==改进==：每次一大块R

$|R| \rightarrow \frac{B(R)}{M}$



小表作外循环效果更佳



#### 散列连接 

3(B(R)+B(S))



M较大时适合嵌套循环



#### 索引连接

用R的每一条数据查找S的索引

$B(R)+|R|log(|S|)$



当两张表都很大时，不适合使用索引连接

当R的条数极小时，索引连接的效率远大于其余



#### 排序归并

先归并排序，排序过程中顺便将它们连接在一起

当其中一张表已经完成排序时可以获得更小的代价



#### 总结

两张表都很大时用哈希

一张表与内存大小相当时使用嵌套循环

一张表数量相当小，在另一张表上有现成的索引时，用索引连接



# 规范化

尽量去冗余化



键：所有属性的集合为U，X是U的子集，X能决定U中其余属性，可以把X里属性设为主键



# 第七章测验二



## 1. 电话号码

每个人有一个主电话号码，如果有多的电话号码，则另开一张表格专门存储。另一张表会很小





