# 数据库系统基本概念

- 存放
- 组织
- 正确性
- 处理平台



# 数据模型

==键值对==

"Zhang San" &rarr; born on Jan 1, 2000

**键值对方法无法逆向查询**


## 数据模型选择

- 易用性

- 功能性



## 数据库功能

==CRUD==

- create
- read
- update
- delete



数据模型需要能够实现以上功能

但是不能保证所有功能都能达到最佳效率



**数据模型决定增删改查的方式**



# 文档数据库

- database: 数据库
- collection: 文档集
- document: 文档

```mysql
{
	"name": "Zhang San",
	"birthday": "Jan 1, 2000",
	"gender": "male"
}
```

此外，存在嵌套文档结构

```mysql
{
	"name": "Zhang San",
	"birthday": {
		"day": 1,
		"month": "Jan",
		"year": 2000
	},
	"gender": "male"
}
```

可以使用树状结构存储



## 基本功能和语法

```mysql
db.myCollection.insertOne({})
```

- `db`：数据库
- `myCollection`：文档集

参数：文档

用于插入一个新的内容



```mysql
db.myCollection.find(
	{
    	"gender": "male",
    	"birthday.year": "2001"
    }
)
```

此处使用一个文档去匹配文档，即**文档匹配**



```mysql
db.myCollection.updateOne(
	{
    	"name": "Zhang San"
    }, --目标
    {
    	$set: {"birthday.year": "2002"}
    }	--改动指令
)
```

改动内容



```mysql
db.myCollection.deleteOne(
	{
    	"name": "Zhang San"
    }
)
```



以上存在的问题：不能**唯一**识别一个对象

为了解决这一问题，系统会为每一个对象自动生成一个`_id`



## 索引

通过数据寻找地址，添加数据到地址的==映射==。

映射本身存在映射复杂度。若计算时间为$O(n)$，则没有意义 （遍历一次的时间复杂度也是如此）

B树计算复杂度为$O(\text{log}(n))$，可以接受，==很常用==

B+树可用常修改的数据作索引，支持点查询和范围查询



**索引被存在硬盘中**，因为索引对内存的消耗过大

每次访问一个页，访问性能由I/O次数决定，而次数由**高度**决定，高度由Block的大小决定（阶，节点大小）

数据充满度对树高的影响不大



B树是平衡的，否则可能形成一棵倾斜的树，复杂度可达到$O(n)$.

B树的节点充满度保证了它的平衡性



复合索引：

> price: Int 4Bytes
>
> Category: Small Int 2 bytes
>
> 索引为6 Bytes，前4个字节为price，后2个字节为Category



包含前缀时查询才有意义，单点查询时最有意义



### 聚簇索引与辅助索引

聚簇索引数据本身按键值排序，辅助索引无排序要求

前者更快

通常一张关系表只有一个聚簇索引，因为只能对一个属性进行排序



选择率：$K/N$，其中$K$为满足查询条件的记录数，$N$为记录数

假设记录存放在$M$个页面中，若$M<K$，则辅助索引无意义

选择率高时，可能访问大部分页面，索引则不适合



**索引的目的**：在大量对象中快速定位目标；避免逐个比对



## 测验2.1

1. 一个文档数据库里面有两类对象，书（book）和人（person）。书和人之间存在一种写作的关系，即某个人是某本书的作者。请问这种写作关系的信息应该如何存放？
   
   万物皆对象，对象之间存在相互引用（指向）的关系。在数据库中，为了能够**唯一**识别引用的对象，需要使用`id`作为标准。

   另外，如果双向引用，则会产生**信息冗余**。在修改任意数据后，需要修改所有对应的内容，造成维护的困难。（程序员不一定直到哪些内容是相关的，改动不一定完整，容易出现数据不一致的问题）

2. 数据库查询语法
   
   不加任何修饰，查询的内容需要完全匹配，也即查询的列表内容完全一致。

   可以通过在文档前添加逻辑词等来筛选，详见操作手册

3. 数据库系统的增、删、改、查操作中的改操作（update）通常可以由一个删操作（delete）和一个增操作（create）实现。但是通常不这么做
   
   - 考虑数据的页式存储方式。如果将改数据拆分为删除和添加，则需要在某一页中删除数据，并在最后一个页中插入新的数据。这样做会在原有的页中留下空洞，造成空间的浪费。
   - 操作复杂
   - 在遇到突发状况如断电，bug等情况下，数据的修改操作可能在进行到一半的时候中断，此时可能出现数据错误。所以需要将这一操作设计为**原子操作**

4. 大部分系统都是对存储空间进行分页管理的。分页的优势包括
   
   - 有利于减少存储空间的碎片化，提升空间利用率
   - 有利于提升数据访问性能
   - 有利于减少空间管理的成本

5. 不适合被放在缓存中的数据
   

## 思考

影响页面大小设置的因素

页大 $\rightarrow$ 页少 $\rightarrow$ 管理成本低

但是，页大 $\rightarrow$ 碎片整理成本高，同时会将大量无用的数据存入缓存（假设缓存中的数据是以页为单位存放的）

对于文档数据库，需要成片访问，所以页面较大 \
对于关系数据库，则页面较小





